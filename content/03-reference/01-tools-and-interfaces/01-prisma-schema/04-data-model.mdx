---
title: 'Data model'
metaTitle: 'Data model (Reference)'
metaDescription: 'Learn about the concepts for building your data model with Prisma: Models, scalar types, enums, attributes, functions, IDs, default values and more.'
tocDepth: 2
---

<TopBlock>

The data model definition part of the [Prisma schema](../) defines your application models (also called **Prisma models**). Models:

* Represent the **entities** of your application domain
* Map to the **tables** in your database
* Form the foundation of the **queries** available in the generated [Prisma Client API](../prisma-client/)

> **Note**: When used with TypeScript, Prisma Client provides generated **type definitions** for your models and any [variations](../prisma-client/advanced-usage-of-generated-types) of them to make database access entirely type safe.

The following schema describes a blogging platform - the data model definition is highlighted:

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

|model User {
| id      Int      @id @default(autoincrement())
| email   String   @unique
| name    String?
| role    Role     @default(USER)
| posts   Post[]
| profile Profile?
|}

|model Profile {
| id      Int     @id @default(autoincrement())
| bio     String
| user    User    @relation(fields: [userId], references: [id])
| userId  Int
|}

|model Post {
| id         Int         @id @default(autoincrement())
| createdAt  DateTime    @default(now())
| title      String
| published  Boolean     @default(false)
| author     User        @relation(fields: [authorId], references: [id])
| authorId   Int
| categories Category[]  @relation(references: [id])
|}

|model Category {
| id    Int     @id @default(autoincrement())
| name  String
| posts Post[]  @relation(references: [id])
|}

|enum Role {
| USER
| ADMIN
|}
```

The data model definition is made up of:

- [Models](#defining-models) ([`model`](prisma-schema-reference#model) <span class="api"></span> primitives) that define a number of fields
- [Enums](#defining-enums) ([`enum`](prisma-schema-reference#enum) <span class="api"></span> primitives) - only available if enums are supported natively by your database
- [Attributes](#defining-attributes) and [functions](#using-functions) that change the behavior of fields and models

The corresponding database looks like this:

![](prisma-schema/sample-database.png)

<details><summary>A model maps to the underlying structures of the data source.</summary>

- In PostgreSQL, a model maps to a _table_
- In MySQL, a model maps to a _table_
- In SQLite, a model maps to a _table_

> **Note**: In the future there might be connectors for non-relational databases and other data sources. For example, for MongoDB a model would map to a _collection_, for a REST API it would map to a _resource_.

</details>

The follow example creates a `User` record and three nested `Post` records, each with one or two nested `Category` records:

<TabbedContent tabs={[<FileWithIcon text="Query Example" icon="code"/>  , <FileWithIcon text="Copy-Paste Example" icon="code"/>]}>	

<tab>

```ts
  const user = await prisma.user.create({
    data: {
      email: "ariadne@prisma.io",
      name: "Ariadne",
      posts: {
        create: [
          {
            title: "My first day at Prisma",
            categories: {
              create: {
                name: "Office",
              },
            },
          },
          {
            title: "How to connect to a SQLite database",
            categories: {
              create: [{ name: "Databases" }, { name: "Tutorials" }],
            },
          },
        ],
      },
    },
  });
```

</tab>

<tab>

```ts
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient({});

// A `main` function so that you can use async/await
async function main() {
  // Create user, posts, and categories
  const user = await prisma.user.create({
    data: {
      email: "ariadne@prisma.io",
      name: "Ariadne",
      posts: {
        create: [
          {
            title: "My first day at Prisma",
            categories: {
              create: {
                name: "Office",
              },
            },
          },
          {
            title: "How to connect to a SQLite database",
            categories: {
              create: [{ name: "Databases" }, { name: "Tutorials" }],
            },
          },
        ],
      },
    },
  });

  // Return user, and posts, and categories
  const returnUser = await prisma.user.findOne({
    where: {
      id: user.id,
    },
    include: {
      posts: {
        include: {
          categories: true,
        },
      },
    },
  });

  console.log(returnUser);
}

main()
  .catch((e) => {
    throw e;
  })
  .finally(async () => {
    await prisma.disconnect();
  });
```

</tab>

</TabbedContent>

Your data model will reflect your application domain. For example:

- In an **e-commerce** application you probably have models like `Customer`, `Order`, `Item` and `Invoice`.
- In a **social media** application you probably have models like `User`, `Post`, `Photo` and `Message`.

</TopBlock>

## Introspection and migration

There are two ways to define a data model:

- **Write the model manually and use Prisma Migrate**: You can write your data model manually and map it to your database using [Prisma Migrate](../prisma-migrate) (experimental). In this case, the data model is the single source of truth for the models of your application.
- **Generate the model via introspection**: When you have an existing database or prefer migrating your database schema with SQL, you generate the data model by [introspecting](../introspection) your database. In this case, the database schema is the single source of truth for the models of your application.

> **Note**: Since [Prisma Migrate](../prisma-migrate) is currently in an experimental state, the officially recommended way for using Prisma is the introspection-based approach.

## Defining models

Models represent the entities of your application domain. Models are represented by [`model`](prisma-schema-reference#inlinecodemodelinlinecode) <span class="api"></span> blocks and define a number of [fields](#fields). In the [example data model](data-model#example), `User`, `Profile`, `Post` and `Category` are models. 

```prisma
model Comment {
   // Fields
}

model Tag {
  // Fields
}
```

### Mapping model names to tables

Prisma model [naming conventions (singular form, PascalCase)](prisma-schema-reference#naming-conventions) do not always match table names in the database. A common approach for naming tables in databases is to use plural form and [snake_case](https://en.wikipedia.org/wiki/Snake_case) notation - for example: `comments`. When you introspect a database with a table named `comments`, the result Prisma model will look like this:

```prisma
model comments {
   // Fields
}
```

However, you can still adhere to the naming convention without renaming the underlying `comments` table in the database by using the [`@@map`](prisma-schema-reference#map-1) <span class="api"></span> attribute:

```prisma
model Comment {

  // Fields
  @@map(name: "comments")
}
```

With this model definition, Prisma automatically maps the `Comment` model to the `comments` table in the underlying database. 

> **Note**: You can also `@map` a column name.

[`@@map`](prisma-schema-reference#map-1) <span class="api"></span> and [`@map`](prisma-schema-reference#map) <span class="api"></span> are often used to [configure your Prisma Client API](../prisma-client/configuring-the-prisma-client-api) by decoupling it from the naming of tables and columns in the underlying database.

## Defining fields

The properties of a model are called _fields_. Fields map to _columns_ and consist of:

- A **field type**
- Optional **type modifiers**
- Optional **attributes**

A field's type determines its _structure_, and fits into one of two categories:

- [Scalar types](data-model#scalar-fields) (includes [enums](data-model#enums)) - for example, `String` or `Int`.
- Model types (the field is then called [relation field](relations#relation-fields)) - for example `Post` or `Comment[]`.

<span class="api"></span>

**API Reference:** [Field types](prisma-schema-reference#field-types), [type modifiers](prisma-schema-reference#model-field-type-modifiers), and [attributes](prisma-schema-reference#attributes)

### Scalar fields

```prisma
model Comment {
|  id      Int    @id @default(autoincrement())
|  title   String
|  content String
}

model Tag {
|  name String @id
}
```

> **Note**: `@id`

### Relation fields

A relation field's type is another model. A [relation](relations) is **always** defined by two relation fields - one on each model. The following example defines:

* A [many-to-many](relations#many-to-many-relations) relation:
  * Each `Post` can have one or more tags (`Tag[]`)
  * Each `Tag` can have one or more posts (`Post[]`)
* A [one-to-many](relations#one-to-many-relations) relation:
  * Each `Comment` is associated with one `Post`
  * Each `Post` can have one or more comments (`Comment[]`)

```prisma
model Post {
  id         Int         @id @default(autoincrement())
  createdAt  DateTime    @default(now())
  title      String
  published  Boolean     @default(false)
  author     User        @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[]  @relation(references: [id])
|  comments   Comment[]
|  tags       Tag[]
}

model Comment {
   id Int 
   title String
   content String
|   Post    Post?  @relation(fields: [postId], references: [id])
   postId  Int?
}

model Tag {
  name   String  
|  posts  Post[]
}
```

> **Note**: _Scalar_ lists (arrays) are only supported in the data model if your database natively supports them. Currently, scalar lists are therefore only supported when using PostgreSQL (since MySQL and SQLite don't natively support scalar lists).

### Optional and mandatory fields

```prisma
model Comment {
  id      Int    @id @default(autoincrement())
  title   String
| content? String
}

model Tag {
  name String @id
}
```

When **not** annotating a field with the `?` type modifier, the field will be _required_ on every record of the model. This has effects on two levels:

- **Database**: Required fields are represented via `NOT NULL` constraints in the underlying database.
- **Prisma Client**: Prisma Client's generated [TypeScript types](#type-definitions) that represent the models in your application code will also define these fields as required to ensure they always carry values at runtime.




**API Reference:** [Type modifiers](prisma-schema-reference#model-field-type-modifiers)



## Defining attributes

Attributes modify the behavior of fields or model blocks. The following example includes two field attributes (`@unique` and `default`) and one block attribute (`@@id`):

```prisma
model User {
  firstName String
  lastName  String
| email     String @unique
| isAdmin   Boolean @default(false)

| @@id([firstName, lastName])
}
```



**API Reference**: [Attributes](prisma-schema-reference#attributes)



### Defining a ID field

An ID uniquely identifies individual records of a model. IDs can be defined by a single field using the `@id` attribute, or multiple fields using the `@@id` attribute.

In the following example, the `User` ID is represented by the `id` field:

```prisma
model User {
| id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  role    Role     @default(USER)
  posts   Post[]
  profile Profile?
}
```

In the following example, the `User` ID is represented by a combination of the `firstName` and `lastName` fields:

```prisma
model User {
  firstName String
  lastName  String
  email     String @unique
  isAdmin   Boolean @default(false)

| @@id([firstName, lastName])
}
```

> **Note**: A model can only have _one_ ID, and that ID can either be a single field or based on multiple fields.




**API Reference:** [`@id`](prisma-schema-reference#id) and [`@@id`](prisma-schema-reference#id-1)



### Defining a unique field

You can add unique attributes to your models to be able to uniquely identify individual records of that model. Unique attributes can be defined on a single field using `@unique` attribute, or on multiple fields (also called composite or compound unique constraints) using the `@@unique` attribute.

In the following example, the value of the `email` field must be unique:

```prisma
model User {
| email String  @unique // `email` can not be optional because it's the only unique field on the model
  name  String?
}
```

In the following example, a combination of `authorId` and `title` must be unique:

```prisma
model Post {
  id         Int         @id @default(autoincrement())
  createdAt  DateTime    @default(now())
  title      String
  published  Boolean     @default(false)
  author     User        @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[]  @relation(references: [id])

| @@unique([authorId, title])
}
```



**API Reference:** [`@unique`](prisma-schema-reference#unique) and [`@@unique`](prisma-schema-reference#unique-1)



### Defining a default value

You can define default values for scalar fields of your models using the `@default` attribute:

```prisma
model Post {
  id         Int         @id @default(autoincrement())
| createdAt  DateTime    @default(now())
  title      String
| published  Boolean     @default(false)
  author     User        @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[]  @relation(references: [id])
}
```

Default values can be:

- Static values that correspond to the field type, such as `5` (`Int`), `Hello` (`String`), or `false` (`Boolean`)
- Functions, such as `now()` or `uuid()`



**API Reference:** [`@default`](prisma-schema-reference#default) and [`attribute functions`](prisma-schema-reference#attribute-functions)




### Defining an index

You can define indexes on one or multiple fields of your models via the `@@index` on a model. The following example defines a multi-column index based on the `title` and `content` field:

```prisma
model Post {
  id       Int     @id @default(autoincrement())
  title    String
  content  String?
  @@index([title, content])
```



**API Reference:** [`@@index`]()




### Relations

You can learn everything about configuration relations on the [Relations](relations) page in the docs.

## Defining enums

You can define enums in your data model if they're supported by the [data source](data-sources) you use:

- PostgreSQL: [Supported](https://www.postgresql.org/docs/9.1/datatype-enum.html)
- MySQL: [Supported](https://dev.mysql.com/doc/refman/8.0/en/enum.html)
- SQLite: Not supported

Enums are considered [scalar](#field-types) types in the Prisma data model. They're therefore [by default](../prisma-client/field-selection#the-default-selection-set) included as return values in [Prisma Client queries](../prisma-client/crud).

Enums are defined via the `enum` block.

## Using functions

The Prisma schema supports a number of functions. These can be used to specify [default values](#default-values) on fields of a model. You can find a reference for all available functions [here](#functions-as-default-values).

## Models in Prisma Client

### Queries (CRUD)

Every model in the data model definition will result in a number of CRUD queries in the generated [Prisma Client API](../prisma-client/):

- `findMany`
- `findOne`
- `create`
- `update`
- `upsert`
- `delete`
- `updateMany`
- `deleteMany`

The operations are accessible via a generated property on the Prisma Client instance. By default the name of the property is the lowercase form of the model name, e.g. `user` for a `User` model or `post` for a `Post` model.

Here is an example illustrating the use of a `user` property from the Prisma Client API:

```js
const newUser = await prisma.user.create({
  data: {
    name: 'Alice',
  },
})
const allUsers = await prisma.user.findMany()
```

### Type definitions

Prisma Client not only provides a query API for models, it also generates type definitions that reflect your model structures. These are part of the generated [`@prisma/client`](../prisma-client/generating-prisma-client#the-prismaclient-npm-package) node module in a file called `index.d.ts`.

When using TypeScript, these type definitions ensure that all your database queries are entirely type safe and validated at compile-time (even partial queries using [`select`](../prisma-client/field-selection#select) or [`include`](../prisma-client/field-selection#include)).

Even when using plain JavaScript, the type definitions are still included in the `@prisma/client` node module, enabling features like [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense)/autocompletion in your editor.

> **Note**: The actual types are stored in the `.prisma/client` folder. `@prisma/client/index.d.ts` exports the contents of this folder.

For example, the type definition for the `User` model from above would look as follows:

```ts
export type User = {
  id: number
  email: string
  name: string | null
  role: string
}
```

Note that the relation fields `posts` and `profile` are not included in the type definition by default. However, if you need variations of the `User` type you can still define them using some of [Prisma Client's generated helper types](../prisma-client/generating-prisma-client) (in this case, these helper types would be called `UserGetIncludePayload` and `UserGetSelectPayload`).
